\documentclass[tikz, border=10pt]{standalone}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows.meta, positioning, fit, calc, backgrounds, shadows, shapes.arrows, shapes.misc}
\usepackage{amsmath, amssymb}

% Colors
\definecolor{lightcyan}{RGB}{220, 245, 255}
\definecolor{myblue}{RGB}{200, 220, 255}
\definecolor{mygreen}{RGB}{210, 255, 180}
\definecolor{darkgreen}{RGB}{100, 180, 80}
\definecolor{myorange}{RGB}{255, 210, 150}
\definecolor{mypink}{RGB}{255, 180, 190}
\definecolor{mydarkpink}{RGB}{230, 100, 120}
\definecolor{myviolet}{RGB}{200, 160, 255}
\definecolor{arrowblack}{RGB}{0, 0, 0}

\begin{document}
\begin{tikzpicture}[
    font=\sffamily,
    >=Latex,
    node distance=0.5cm,
    % Styles
    basebox/.style={draw, rounded corners, align=center, line width=0.8pt, font=\small},
    titlebox/.style={fill=lightcyan, draw=none, minimum height=0.8cm, text width=11cm, align=center, font=\bfseries\small},
    sectiontitle/.style={font=\bfseries\large, align=center},
    container/.style={draw, line width=1pt, rounded corners, inner sep=10pt},
    process/.style={basebox, fill=white, draw=black, minimum height=0.7cm},
    bigarrow/.style={single arrow, fill=black, draw=none, minimum height=1cm, single arrow head extend=0.2cm},
    ]

    % =========================================================
    % LEFT COLUMN
    % =========================================================
    
    % 1. Input Header
    \node[titlebox] (input) {Network Traffic Input (Protocol, Flow Duration, Flow Bytes/s, Total Packets, $\cdots$)};
    
    % Down Arrow
    \node[below=0.1cm of input] (arrow1) {};
    \draw[fill=black] (arrow1.north) -- ++(0,-0.3) -- ++(0.2,0) -- ++(-0.2,-0.3) -- ++(-0.2,0.3) -- ++(0.2,0) -- cycle;
    % Or use single arrow shape for better look
    \node[single arrow, fill=black, rotate=-90, minimum height=0.8cm, below=0.1cm of input] (arrow1_node) {};

    % 2. Feature Engineering Module
    \node[sectiontitle, below=0.1cm of arrow1_node] (fe_title) {Feature Engineering and Selection Module};
    
    \node[container, fill=myblue!40, draw=blue!60!black, fit={(fe_title) ($(fe_title)+(0,-3.5)$) ($(fe_title)+(11.5,0)$) ($(fe_title)+(-0.5,0)$)}, inner sep=0pt, below=0.1cm of fe_title] (fe_box) {};
    
    % Adjust fe_box size manually or let it fit content. Let's place content relative to title and fit box later.
    % Actually, let's redefine the container to fit content.
    
    % Multi-Entropy Box (Left inside FE)
    \node[basebox, fill=blue!10, draw=blue!40, minimum width=4.5cm, minimum height=2cm, below right=0.5cm and 0.5cm of fe_title.south west, anchor=north west, xshift=-0.5cm] (entropy_box) {};
    \node[below=0.1cm of entropy_box.north, font=\bfseries] {Multi-Entropy Computation};
    
    \node[process, fill=white, minimum width=1.2cm, above=0.2cm of entropy_box.south, xshift=-1.5cm] (shannon) {Shannon};
    \node[process, fill=white, minimum width=1.2cm, right=0.2cm of shannon] (renyi) {RÃ©nyi};
    \node[process, fill=white, minimum width=1.2cm, right=0.2cm of renyi] (min) {Min};

    % Pink Arrow
    \node[single arrow, fill=magenta!60, minimum height=1cm, right=0.3cm of entropy_box] (pink_arrow) {};

    % Formula Box (Right inside FE)
    \node[right=0.3cm of pink_arrow, align=center, text width=5cm] (formula) {
        {\Huge $H(X \mid \text{ddos})$} \\[0.5em]
        \textbf{Select top 10\% of features with \\ lowest conditional entropy}
    };
    
    % Re-draw FE container to fit
    \node[container, fill=myblue!40, draw=blue!60!black, fit={(entropy_box) (formula) (fe_title)}, inner sep=10pt] (fe_container) {};
    % Move title properly inside
    \node[sectiontitle, above=0.2cm of fe_container.center, yshift=1.2cm] (fe_title_real) {Feature Engineering and Selection Module};


    % 3. Stage 1 Module
    \node[single arrow, fill=black, rotate=-90, minimum height=0.8cm, below=0.2cm of fe_container] (arrow2_node) {};
    \node[sectiontitle, below=0.2cm of arrow2_node] (st1_title) {Stage 1: PSO-GMM Anomalous Traffic Clustering Module};

    % GMM Logic (Left inside St1)
    \node[basebox, fill=green!20, draw=darkgreen, minimum width=5.5cm, minimum height=4.5cm, below=0.5cm of st1_title, xshift=-3cm] (gmm_logic) {};
    \node[below=0.1cm of gmm_logic.north, font=\bfseries, align=center, fill=darkgreen!80, text=white, minimum width=5cm, rounded corners] (gmm_title) {GMM Initialization Optimization \\ Module (PSO-based)};
    
    % EM Box
    \node[basebox, fill=darkgreen!10, draw=black, minimum width=4.5cm, minimum height=2.5cm, below=0.2cm of gmm_title] (em_box) {};
    \node[below=0.1cm of em_box.north, font=\bfseries] {EM algorithm iteration};
    \node[process, fill=green!5, minimum width=4cm, below=0.5cm of em_box.north] (estep) {E-Step $\mid \to \mathbf{\gamma}$};
    \node[process, fill=green!5, minimum width=4cm, below=0.2cm of estep] (mstep) {M-Step $\mid \to \{ \mathbf{\mu}, \mathbf{\Sigma}, \mathbf{\pi} \}$};
    
    % Cycle Arrows
    \node[right=0.1cm of em_box, font=\LARGE] (cycle) {$\boldsymbol{\circlearrowright}$};
    \node[above=0cm of cycle, font=\scriptsize] {Iteration};
    
    \node[below=0.1cm of em_box, align=center, font=\scriptsize] {Convergence check (Log-\\Likelihood) and output $\theta^*$};

    % Objective Function (Right Top inside St1)
    \node[basebox, fill=darkgreen!10, draw=none, minimum width=6cm, minimum height=2.5cm, right=0.5cm of gmm_logic, anchor=north west] (obj_box) {};
    \node[below=0.1cm of obj_box.north, font=\bfseries, align=center, fill=darkgreen!80, text=white, minimum width=5.5cm, rounded corners] {Objective Function};
    \node at ($(obj_box.center) + (0,-0.3)$) {
        \resizebox{5.5cm}{!}{
        $F(\mathbf{w}) =
        \begin{cases}
        \min\limits_{k \in K} \left[ -w_{\text{ddos}} \frac{d_k}{N} + w_{\text{benign}} \frac{b_k}{d_k + b_k} \right], & \text{if } \exists k \in K : \frac{d_k}{d_k + b_k} \ge \theta \\
        \lambda_{\text{penalty}}, & \text{otherwise}.
        \end{cases}$
        }
    };

    % Output Classification (Right Bottom inside St1)
    \node[basebox, fill=myorange, draw=orange!80!black, minimum width=6cm, minimum height=1.8cm, below=0.2cm of obj_box] (class_box) {};
    \node[below=0.1cm of class_box.north, font=\bfseries] {Output cluster classification:};
    \node[below=0.5cm of class_box.north, align=left, font=\small] {
        1. $\ge \theta \to$ cddos (high-purity DDoS) \\
        2. $< \theta \to$ cmixed (passed to stage 2 \\ \hspace{1em} for further analysis)
    };
    
    % Green Arrow
    \node[single arrow, fill=mygreen!80!darkgreen, minimum height=1cm, right=0.2cm of gmm_logic.south east, anchor=west] (green_arrow) {};

    % St1 Container
    \node[container, fill=mygreen!40, draw=darkgreen, fit={(st1_title) (gmm_logic) (class_box)}, inner sep=10pt] (st1_container) {};
    
    
    % =========================================================
    % RIGHT COLUMN: Stage 2
    % =========================================================
    
    \node[container, fill=mygreen!30, draw=darkgreen, minimum width=10cm, minimum height=12cm, right=1.5cm of fe_container.north east, anchor=north west] (st2_container) {};
    \node[below=0.2cm of st2_container.north, font=\bfseries\Large] (st2_title) {Stage-2 : Deep Analysis};
    
    % Connect Stage 1 to Stage 2 with Big Black Arrow
    \node[single arrow, fill=black, minimum height=1.5cm, right=0.2cm of st1_container.east, yshift=-3cm] (big_arrow_mix) {};
    \node[below=0.1cm of big_arrow_mix, font=\bfseries] {cmixed};
    % Note: Positioning of right column needs to be aligned.
    % Let's align st2_container relative to st1_container
    
    % Adjust st2 position
    \node[container, fill=mygreen!20, draw=darkgreen, inner sep=10pt, fit={(st2_title) ($(st2_title)+(9,-10)$)}, right=1.5cm of st1_container.north east, anchor=north west, yshift=2cm] (st2_real) {};
     \node[below=0.2cm of st2_real.north, font=\bfseries\Large] {Stage-2 : Deep Analysis};

    % Stack (Left side of Stage 2)
    \coordinate (stack_x) at ($(st2_real.west) + (2cm, 0)$);
    \coordinate (stack_top) at ($(st2_real.north west) + (2cm, -1.5cm)$);
    
    \node[above=0.1cm of stack_top, font=\small, draw, dashed] (input_dim) {$cmixed[B, T, Din]$};
    \draw[->, thick] (input_dim) -- (stack_top);
    
    \node[pinkbox, minimum width=3cm, anchor=north] (lin1) at (stack_top) {Linear+\\LayerNorm+Dropout};
    \node[pinkbox, minimum width=3cm, below=0.3cm of lin1] (posenc) {Positional Encoding};
    
    % Mamba Stack
    \node[basebox, fill=cyan!10, draw=black, minimum width=3cm, minimum height=1.5cm, below=0.3cm of posenc] (mamba_stack) {};
    \foreach \i in {1,2,3} {
        \node[basebox, fill=cyan!10, draw=black, minimum width=3cm, minimum height=1cm, anchor=center] at ($(mamba_stack.center) + (\i*2pt, \i*2pt)$) {};
    }
    \node[basebox, fill=cyan!10, draw=black, minimum width=3cm, minimum height=1cm, below=0.3cm of posenc] (mamba_block) {Mamba block};
    \node[left=0.1cm of mamba_block] {x4};
    
    \node[violetbox, minimum width=3cm, below=0.3cm of mamba_stack] (pool) {Mean Pooling};
    \node[darkgreenbox, minimum width=3cm, below=0.3cm of pool] (ffn) {FFN};
    \node[pinkbox, minimum width=3cm, below=0.3cm of ffn] (lin2) {LayerNorm+Dropout};
    \node[orangebox, rounded corners=10pt, minimum width=3cm, below=0.3cm of lin2] (sigmoid) {Linear $\to$ Sigmoid};
    
    % Stack arrows
    \draw[->, thick] (lin1) -- (posenc);
    \draw[->, thick] (posenc) -- (mamba_block);
    \draw[->, thick] (mamba_stack) -- (pool);
    \draw[->, thick] (pool) -- (ffn);
    \draw[->, thick] (ffn) -- (lin2);
    \draw[->, thick] (lin2) -- (sigmoid);
    
    
    % Detail View (Right side of Stage 2)
    \node[process, fill=white, minimum width=5cm, minimum height=8cm, right=1cm of mamba_stack, yshift=-1cm] (detail_whitebox) {};
    \node[anchor=north east, font=\bfseries] at (detail_whitebox.north east) {Mamba};
    
    \coordinate (detail_top_c) at ($(detail_whitebox.north) + (0, -0.8)$);
    
    % Input Array
    \foreach \x in {-3,-2,-1,0,1,2} 
        \fill[cyan!40] ($(detail_top_c) + (\x*0.3, 0)$) rectangle ++(0.25, 0.25);
    \node[below left=0.1cm of detail_top_c, xshift=-1cm] {Input};
    \coordinate (d_in) at ($(detail_top_c) + (0, -0.1)$);
    
    % Split
    \coordinate (split) at ($(d_in) + (0, -0.5)$);
    \draw[thick] (d_in) -- (split);
    
    % Left Branch (Active)
    \node[trapezium, draw=darkgreen, fill=green!20, trapezium left angle=60, trapezium right angle=60, minimum width=1.2cm, below left=0.5cm and 0.5cm of split] (proj1) {\scriptsize Projection};
    \node[basebox, fill=cyan!10, below=0.3cm of proj1, minimum width=1.2cm] (conv) {\scriptsize Conv};
    \node[circle, fill=mypink, inner sep=1pt, below=0.3cm of conv] (silu1) {$\sigma$}; \node[right=0cm of silu1, font=\tiny] {SiLU};
    \node[basebox, fill=blue!10, below=0.3cm of silu1, minimum width=1.2cm] (ssm) {\scriptsize SSM};
    
    % Right Branch (Gating)
    \node[trapezium, draw=darkgreen, fill=green!20, trapezium left angle=60, trapezium right angle=60, minimum width=1.2cm, below right=0.5cm and 0.5cm of split] (proj2) {\scriptsize Projection};
    \node[circle, fill=mypink, inner sep=1pt] (silu2) at (silu1 -| proj2) {$\sigma$}; \node[right=0cm of silu2, font=\tiny] {SiLU};
    
    % Connections
    \draw[thick] (split) -| (proj1);
    \draw[thick] (split) -| (proj2);
    \draw[thick] (proj1) -- (conv);
    \draw[thick] (conv) -- (silu1);
    \draw[thick] (silu1) -- (ssm);
    \draw[thick] (proj2) -- (silu2);
    
    % Multiply
    \node[circle, draw, cross out, inner sep=2pt, minimum size=0.4cm, below=0.3cm of ssm] (mult) {};
    \draw[thick] (ssm) -- (mult);
    \draw[thick] (silu2) |- (mult);
    
    % Final Proj
    \node[trapezium, draw=darkgreen, fill=green!20, trapezium left angle=60, trapezium right angle=60, minimum width=1.2cm, below=0.3cm of mult] (proj_final) {\scriptsize Projection};
    \draw[thick] (mult) -- (proj_final);
    
    % Output Array
    \coordinate (d_out) at ($(proj_final.south) + (0, -0.5)$);
    \foreach \x in {-3,-2,-1,0,1,2} 
        \fill[mypink] ($(d_out) + (\x*0.3, 0)$) rectangle ++(0.25, 0.25);
    \node[above left=0.1cm of d_out, xshift=-1cm] {Output};
    \draw[thick] (proj_final) -- (d_out);
    
    % Zoom Lines
    \draw[dashed, thick, cyan, ->] (mamba_block.east) to[out=0, in=180] ($(detail_top_c)+(-1.5,0)$);
    \draw[dashed, thick, mypink, ->] ($(d_out)+(-1.5,0)$) to[out=180, in=0] (mamba_block.east);

    % Final Output Arrow
    \node[single arrow, fill=black, minimum height=1cm, right=0.2cm of sigmoid] (final_arrow) {};
    \node[right=0.1cm of final_arrow, font=\bfseries\large] {Block or Pass};
    \node[above=0.1cm of final_arrow, font=\footnotesize] {Output [B, 1]};

\end{tikzpicture}
\end{document}
